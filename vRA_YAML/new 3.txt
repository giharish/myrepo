 function Handler($context, $inputs) {
    $inputsString = $inputs | ConvertTo-Json -Compress
    $vcfqdn = $inputs.vcfqdn
    $vcuser = $inputs.customProperties.vc_user
    $vcpassword = $inputs.customProperties.vc_pass
    $script = $inputs.script
    $remoteuser = $inputs.customProperties.tmpl_user
    $remotepassword = $inputs.customProperties.tmpl_pass
    $name = $inputs.resourceNames[0]
    $hostname = $inputs.customProperties.hostname
    $ip = $inputs.ipAddress
    Connect-VIServer $vcfqdn -User $vcuser -Password $vcpassword -Force
    write-host “Waiting for VM Tools to Start”
    do {
    $toolsStatus = (Get-vm -name $name | Get-View).Guest.ToolsStatus
    write-host $toolsStatus
    sleep 3
    } until ( $toolsStatus -eq ‘toolsOk’ )
    $vm = Get-vm -name $name
    $output = $inputs.customProperties.softwareName
    Write-Host "VM OS Type is "$output
    
    if ($output -Match "Windows") {
        $os_type = "Minion installed on Windows"
        $script = "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope CurrentUser; Invoke-WebRequest https://repo.saltstack.com/windows/Salt-Minion-3002-Py3-x86-Setup.exe -UseBasicParsing -OutFile ~\Downloads\minion.exe"
        $script2 = "~\Downloads\minion.exe /S /master=$ip /minion-name=$hostname"
        $runscript = Invoke-VMScript -VM $vm -ScriptText $script -GuestUser $remoteuser -GuestPassword $remotepassword -ToolsWaitSecs 300
        Write-Host $runscript.ScriptOutput
        $runscript2 = Invoke-VMScript -VM $vm -ScriptText $script2 -GuestUser $remoteuser -GuestPassword $remotepassword -ToolsWaitSecs 300
        Write-Host $runscript2.ScriptOutput
        Write-Host "Minion installed on Windows using EXE"
    } else {
        $os_type = "Minion installed on Linux"
        $script = "curl -L https://bootstrap.saltstack.com -o install_salt.sh && sudo hostnamectl set-hostname $hostname && sudo chmod 777 install_salt.sh && sudo sh install_salt.sh -A $ip"
        Write-Host $script
        $runscript = Invoke-VMScript -VM $vm -ScriptText $script -GuestUser $remoteuser -GuestPassword $remotepassword -ToolsWaitSecs 300
        Write-Host $runscript.ScriptOutput
        Write-Host = "Used bootstrap"
    }

    return $os_type
}

def handler(context, inputs):
    import paramiko
    host = inputs["hostname"]
    user = inputs["username"]
    passwd = inputs["password"]
    name = inputs["name"]
    
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    client.connect(host, username=user, password=passwd, look_for_keys=False)
    command = "sudo salt-key -y -A " + name + " > /tmp/salt.out"
    print(command)
    (stdin, stdout, stderr) = client.exec_command(command)
    for line in stdout:
        print(line.strip('\n'))
    client.close()
    

def handler(context, inputs):
    import paramiko
    hostname = inputs["hostname"]
    username = inputs["username"]
    password = inputs["password"]
    
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    client.connect(hostname, username=username, password=password, look_for_keys=False)
    
    (stdin, stdout, stderr) = client.exec_command('ls -l')
    
    for line in stdout:
        print(line.strip('\n'))
    
    client.close()
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAr2F/z0AjFWi5t0YxMOw0
wHQO6/2tlQ8vVLBSXHoM4w2MFHRaxyWpapJMQMLKiueDf+V14n86JMqUJM9ctHvE
J3JCP84nkEORbhmJJsXHGpee3SWPEwACAeCMqRUfdv3HUcbzMw0brpSPVPUPvwgI
E6YtUV3vo3Dl+cfTywA6lMqG0Dpftntneswe6zszDGZ/teR0dcstGZqGQob4WoMe
CYy62obOWKkcVYWSxttYTcCKXuNVJyEOTjL2iVoWk9ywLyjn+uA8HUKpx47qvNcb
f9krjHLLDUbvvo/MQou6qnQuTwReR6wRk2SvnO2AX6VmgQQod1g9el60XHKzN4DM
qwIDAQAB

salt-run state.event pretty=true

Adding Annotation and Attributes

// Javascript: Set Notes
//    Inputs: vm (VC:VirtualMachine), inputProperties (Properties)
//    Outputs: None

var notes = inputProperties.customProperties.description
var poc = inputProperties.customProperties.poc
var ticket = inputProperties.customProperties.ticket

var spec = new VcVirtualMachineConfigSpec()
spec.annotation = notes
vm.reconfigVM_Task(spec)

System.getModule("com.vmware.library.vc.customattribute").setOrCreateCustomField(vm,"Point of Contact", poc)
System.getModule("com.vmware.library.vc.customattribute").setOrCreateCustomField(vm,"Ticket", ticket)

YAML Code:
inputs:
[...]
  description:
    type: string
    title: Description
    description: Server function/purpose
    default: Testing and evaluation
  poc_name:
    type: string
    title: Point of Contact Name
    default: Jack Shephard
  poc_email:
    type: string
    title: Point of Contact Email
    default: jack.shephard@virtuallypotato.com
    pattern: '^[^\s@]+@[^\s@]+\.[^\s@]+$'
  ticket:
    type: string
    title: Ticket/Request Number
    default: 4815162342
resources:
  Cloud_vSphere_Machine_1:
    type: Cloud.vSphere.Machine
    properties:
      <...>
      poc: '${input.poc_name + " (" + input.poc_email + ")"}'
      ticket: '${input.ticket}'
      description: '${input.description}'
      <...>
	  
	  
<# vRA 8.x ABX action to perform certain in-guest actions post-deploy:
    Windows:
        - auto-update VM tools
        - add specified domain users/groups to local Administrators group
        - extend C: volume to fill disk
        - set up remote access
        - create a scheduled task to (attempt to) apply Windows updates
    
    ## Action Secrets:
        templatePassWinDomain                   # password for domain account with admin rights to the template (domain-joined deployments)
        templatePassWinWorkgroup                # password for local account with admin rights to the template (standalone deployments)
        vCenterPassword                         # password for vCenter account passed from the cloud template
    
    ## Action Inputs:
    ## Inputs from deployment:
        resourceNames[0]                        # VM name [BOW-DVRT-XXX003]
        customProperties.vCenterUser            # user for connecting to vCenter [lab\vra]
        customProperties.vCenter                # vCenter instance to connect to [vcsa.lab.bowdre.net]
        customProperties.dnsDomain              # long-form domain name [lab.bowdre.net]
        customProperties.adminsList             # list of domain users/groups to be added as local admins [john, lab\vra, vRA-Admins]
        customProperties.adJoin                 # boolean to determine if the system will be joined to AD (true) or not (false)
        customProperties.templateUser           # username used for connecting to the VM through vmtools [Administrator] / [root]
#>

function handler($context, $inputs) {
    # Initialize global variables
    $vcUser = $inputs.customProperties.vCenterUser
    $vcPassword = $context.getSecret($inputs."vCenterPassword")
    $vCenter = $inputs.customProperties.vCenter
    
    # Create vmtools connection to the VM 
    $vmName = $inputs.resourceNames[0]
    Connect-ViServer -Server $vCenter -User $vcUser -Password $vcPassword -Force
    $vm = Get-VM -Name $vmName
    Write-Host "Waiting for VM Tools to start..."
    if (-not (Wait-Tools -VM $vm -TimeoutSeconds 180)) {
        Write-Error "Unable to establish connection with VM tools" -ErrorAction Stop
    }
    
    # Detect OS type
    $count = 0
    While (!$osType) {
        Try {
            $osType = ($vm | Get-View).Guest.GuestFamily.ToString()
            $toolsStatus = ($vm | Get-View).Guest.ToolsStatus.ToString()        
        } Catch {
            # 60s timeout
            if ($count -ge 12) {
                Write-Error "Timeout exceeded while waiting for tools." -ErrorAction Stop
                break
            }
            Write-Host "Waiting for tools..."
            $count++
            Sleep 5
        }
    }
    Write-Host "$vmName is a $osType and its tools status is $toolsStatus."
    
    # Update tools on Windows if out of date
    if ($osType.Equals("windowsGuest") -And $toolsStatus.Equals("toolsOld")) {
        Write-Host "Updating VM Tools..."
        Update-Tools $vm
        Write-Host "Waiting for VM Tools to start..."
        if (-not (Wait-Tools -VM $vm -TimeoutSeconds 180)) {
            Write-Error "Unable to establish connection with VM tools" -ErrorAction Stop
        }
    }
    
    # Run OS-specific tasks
    if ($osType.Equals("windowsGuest")) {
        # Initialize Windows variables
        $domainLong = $inputs.customProperties.dnsDomain
        $adminsList = $inputs.customProperties.adminsList
        $adJoin = $inputs.customProperties.adJoin
        $templateUser = $inputs.customProperties.templateUser
        $templatePassword = $adJoin.Equals("true") ? $context.getSecret($inputs."templatePassWinDomain") : $context.getSecret($inputs."templatePassWinWorkgroup")
      
        # Add domain accounts to local administrators group
        if ($adminsList.Length -gt 0 -And $adJoin.Equals("true")) {
            # Standardize users entered without domain as DOMAIN\username
            if ($adminsList.Length -gt 0) {
                $domainShort = $domainLong.split('.')[0]
                $adminsArray = @(($adminsList -Split ',').Trim())
                For ($i=0; $i -lt $adminsArray.Length; $i++) {
                    If ($adminsArray[$i] -notmatch "$domainShort.*\\" -And $adminsArray[$i] -notmatch "@$domainShort") {
                        $adminsArray[$i] = $domainShort + "\" + $adminsArray[$i]
                    }
            }
            $admins = '"{0}"' -f ($adminsArray -join '","')
            Write-Host "Administrators: $admins"
            }
            $adminScript = "Add-LocalGroupMember -Group Administrators -Member $admins"
            Start-Sleep -s 10
            Write-Host "Attempting to add administrator accounts..."
            $runAdminScript = Invoke-VMScript -VM $vm -ScriptText $adminScript -GuestUser $templateUser -GuestPassword $templatePassword
            if ($runAdminScript.ScriptOutput.Length -eq 0) {
                Write-Host "Successfully added [$admins] to Administrators group."
            } else {
                Write-Host "Attempt to add [$admins] to Administrators group completed with warnings:`n" $runAdminScript.ScriptOutput "`n"
            }
        } else {
            Write-Host "No admins to add..."
        }
        # Extend C: volume to fill system drive
        $partitionScript = "`$Partition = Get-Volume -DriveLetter C | Get-Partition; `$Partition | Resize-Partition -Size (`$Partition | Get-PartitionSupportedSize).sizeMax"
        Start-Sleep -s 10
        Write-Host "Attempting to extend system volume..."
        $runPartitionScript = Invoke-VMScript -VM $vm -ScriptText $partitionScript -GuestUser $templateUser -GuestPassword $templatePassword
        if ($runPartitionScript.ScriptOutput.Length -eq 0) {
            Write-Host "Successfully extended system partition."
        } else {
            Write-Host "Attempt to extend system volume completed with warnings:`n" $runPartitionScript.ScriptOutput "`n"
        }
        # Set up remote access
        $remoteScript = "Enable-NetFirewallRule -DisplayGroup `"Remote Desktop`"
            Enable-NetFirewallRule -DisplayGroup `"Windows Management Instrumentation (WMI)`"
            Enable-NetFirewallRule -DisplayGroup `"File and Printer Sharing`"
            Enable-PsRemoting
            Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -name `"fDenyTSConnections`" -Value 0"
        Start-Sleep -s 10
        Write-Host "Attempting to enable remote access (RDP, WMI, File and Printer Sharing, PSRemoting)..."
        $runRemoteScript = Invoke-VMScript -VM $vm -ScriptText $remoteScript -GuestUser $templateUser -GuestPassword $templatePassword
        if ($runRemoteScript.ScriptOutput.Length -eq 0) {
            Write-Host "Successfully enabled remote access."
        } else {
            Write-Host "Attempt to enable remote access completed with warnings:`n" $runRemoteScript.ScriptOutput "`n"
        }
        # Create scheduled task to apply updates
        $updateScript = "`$action = New-ScheduledTaskAction -Execute 'C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe' -Argument '-NoProfile -WindowStyle Hidden -Command `"& {Install-WUUpdates -Updates (Start-WUScan)}`"'
            `$trigger = New-ScheduledTaskTrigger -Once -At ([DateTime]::Now.AddMinutes(1))
            `$settings = New-ScheduledTaskSettingsSet -Compatibility Win8 -Hidden
            Register-ScheduledTask -Action `$action -Trigger `$trigger -Settings `$settings -TaskName `"Initial_Updates`" -User `"NT AUTHORITY\SYSTEM`" -RunLevel Highest
            `$task = Get-ScheduledTask -TaskName `"Initial_Updates`"
            `$task.Triggers[0].StartBoundary = [DateTime]::Now.AddMinutes(1).ToString(`"yyyy-MM-dd'T'HH:mm:ss`")
            `$task.Triggers[0].EndBoundary = [DateTime]::Now.AddHours(3).ToString(`"yyyy-MM-dd'T'HH:mm:ss`")
            `$task.Settings.AllowHardTerminate = `$True
            `$task.Settings.DeleteExpiredTaskAfter = 'PT0S'
            `$task.Settings.ExecutionTimeLimit = 'PT2H'
            `$task.Settings.Volatile = `$False
            `$task | Set-ScheduledTask"
        Start-Sleep -s 10
        Write-Host "Creating a scheduled task to apply updates..."
        $runUpdateScript = Invoke-VMScript -VM $vm -ScriptText $updateScript -GuestUser $templateUser -GuestPassword $templatePassword
        Write-Host "Created task:`n" $runUpdateScript.ScriptOutput "`n"            
    } elseif ($osType.Equals("linuxGuest")) {
        #TODO
        Write-Host "Linux systems not supported by this action... yet"
    }
    # Cleanup connection
    Disconnect-ViServer -Server $vCenter -Force -Confirm:$false

}

'${env.requestedBy}'

Stop-Service -Name 'MSSQL$SQLDB01'
set-itemproperty -path 'HKLM:\software\microsoft\microsoft sql server\mssql15.SQLDB01\mssqlserver\supersocketnetlib\tcp\ipall' -name tcpdynamicports -value ''
set-itemproperty -path 'HKLM:\software\microsoft\microsoft sql server\mssql15.SQLDB01\mssqlserver\supersocketnetlib\tcp\ipall' -name tcpport -value 1433
set-itemproperty -path 'HKLM:\software\microsoft\microsoft sql server\mssql15.SQLDB01\mssqlserver\' -name LoginMode -value 2
Restart-Service -Name 'MSSQL$SQLDB01'

$svcname = "'" + 'MSSQL$SQLDB01' + "'"

https://sqlserverpowershell.com/2015/02/17/change-the-sa-password-in-sql-server-via-powershell/

import-module SqlPS -DisableNameChecking
[string]$newPwd = 'C0mp13xP@55word%'
 
 
try{
    gc -Path c:\Servers.txt | %{
 
        $srvName = $_
        $srv = New-Object Microsoft.SqlServer.Management.Smo.Server $srvName
        $srv.Logins | where{$_.Name -eq 'sa'} | %{
            $_.ChangePassword($newPwd);
        }
    }
}
catch{
    $_ | fl -Force
}

Register-PSRepository -Name Local -SourceLocation C:\PS -InstallationPolicy Trusted


$password =  ConvertTo-SecureString "VMware1!VMware1!" -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential("$env:COMPUTERNAME\sqladmin", $password)
Enable-PSRemoting –force
$sysadmacc = echo $env:COMPUTERNAME\sqladmin
Invoke-Command -ScriptBlock {C:\SQL\Setup.exe /SAPWD=VMware1!VMware1! /IACCEPTSQLSERVERLICENSETERMS /Q /FEATURES=SQLENGINE /ACTION=INSTALL /SQLSYSADMINACCOUNTS=$sysadmacc /SECURITYMODE="SQL" /TCPENABLED="1" /NPENABLED="0"} -Credential $credential -ComputerName $env:COMPUTERNAME
Disable-PSRemoting -Force

Invoke-Command -Session $session -ScriptBlock {.\Setup.exe /SAPWD=VMware1!VMware1! /IACCEPTSQLSERVERLICENSETERMS /Q /FEATURES=SQLENGINE /ACTION=INSTALL /SQLSYSADMINACCOUNTS="hostname\Administrator" /SECURITYMODE="SQL" /TCPENABLED="1" /NPENABLED="0" /BROWSERSVCSTARTUPTYPE="Automatic"}
$password =  ConvertTo-SecureString "VMware1!" -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential("$env:COMPUTERNAME\pocadmin", $password)
  Invoke-Command -ScriptBlock {C:\SQL\Setup.exe /SAPWD=VMware1!VMware1! /IACCEPTSQLSERVERLICENSETERMS /Q /FEATURES=SQLENGINE /ACTION=INSTALL /SQLSYSADMINACCOUNTS=$using:sysadmacc /SECURITYMODE="SQL" /TCPENABLED="1" /NPENABLED="0"} -Credential $credential -ComputerName localhost
$SApwd = "MyPassword"
$ServiceAccount= "SPRINGFIELD\SQLCitrix"    $ServicePassword = "MyPassword"
$SqlCollation = "French_CI_AS"
$user = "Springfield\Administrator"
$password = ConvertTo-SecureString -AsPlainText -Force -String "MyPassword"
$credentials = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $user,$password
$session = New-PSSession -ComputerName $ipsqlserver -Credential $credentials
$sysadmacc = echo $env:COMPUTERNAME\sqladmin
Invoke-Command -ScriptBlock {C:\SQL\Setup.exe /SAPWD=$using:SApwd /IACCEPTSQLSERVERLICENSETERMS /Q /FEATURES=SQLENGINE /ACTION=INSTALL /SQLSYSADMINACCOUNTS=$sysadmacc /SECURITYMODE="SQL" /TCPENABLED="1" /NPENABLED="0"} -Credential $credential -ComputerName $env:COMPUTERNAME